@startuml
'https://plantuml.com/class-diagram

class Lisp
class Lexer
class Parser
class Interpreter
class ArithmeticFunctions
class functionHelper
class LogicFunctions
class Context
Lisp ..> Lexer
Lisp ..> Parser
Lisp ..> Interpreter

abstract class TreeNode
class Atom
class SExpression

class PrimitiveFunctions
class SymbolPatterns{
   + String ( WHITESPACE )
   + String ( NUMBER )
   + String (BOOLEAN)
   + String ( LITERAL )
   + String ( Valid_Function_Name )
   + String ( VALID_VARIABLE_NAME )
   + String ( ARITHMETIC_OPERATOR )
   + String ( LOGIC_OPERATOR )
   + String ( EXPRESSION_OPENER )
   + String ( EXPRESSION_CLOSER )



}

Parser "uses" ..> TreeNode
SymbolPatterns "uses" ...> SExpression
TreeNode <|-- "inherits" Atom
TreeNode <|-- "inherits" SExpression
SExpression "contains" o--> Atom
 PrimitiveFunctions <- SExpression

class Lexer {
    + getTokens( Stream ) : ArrayList<String>
    - streamToString (Stream) : String
    - prepare( Stream ) : String
    - divide (String) : ArrayList<String>
    - wrap (String) : String

}

class Parser {
    + buildTree ( ArrayList<String> ) : TreeNode
    + buildTree ( String ) : TreeNode
    + buildTree ( List<String> ) : TreeNode


}

class Interpreter {
    + evaluate (TreeNode) : String
}

class TreeNode <<Abstract>>{
    # tokens : ArrayList<String>
    + isList () : Boolean
    + evaluate() : TreeNode
    + toString() : String
    + create ( ArrayList<String> ) : TreeNode
    + create ( boolean ) : TreeNode
    + create ( int ) : TreeNode

}

class Atom {
    - value : String
    + toString() : String
    + isAtom() : Boolean
    + Atom() :  int
    + Atom() :  double




}

class SExpression {
    'Talvez los tokens no sen necesarios'
    # tokens : ArrayList<String>
    - childNodes : ArrayList<TreeNode>
    + toString() : String
    - isValid(String) : boolean
    - getNextClosedParentesis (int start)
}

class PrimitiveFunctions{
   + SUM( SExpression )
   + SUBTRACTION( SExpression )
   + DIVISION( SExpression )
   + MULTIPLICATION( SExpression )
   + CAR ( SExpression )
   + CDR ( SExpression )
   + SETQ ( SExpression )
   + COND ( SExpression )
   + QUOTE ( SExpression )
   + ATOM ( SExpression )
   + DEFUN ( SExpression )

}
class ArithmeticFunctions{
    + add(List<TreeNode>) : TreeNode
    + substraction(List<TreeNode>) : TreeNode
    + multiplication(List<TreeNode>) : TreeNode
    + division(List<TreeNode>) : TreeNode

}
class functionHelper{
    + isNodeType(TreeNode String) : boolean
    + getFirstMember(List<TreeNode>) : TreeNode
    + getRemainingMembers(List<TreeNode>) : (List<TreeNode>)
    + nodeAsNumeric (TreeNode) : double

}
class LogicFunctions {
    + not(List<TreeNode>) : TreeNode
    + eq(List<TreeNode>) : TreeNode
    + ne(List<TreeNode>) : TreeNode
    + lt(List<TreeNode>) : TreeNode
    + gt(List<TreeNode>) : TreeNode
    + ge(List<TreeNode>) : TreeNode
    + atom(List<TreeNode>) : TreeNode

}
class Context{
    -HashMap : Map<String TreeNode>
    -HashMap : Map<String userFunction>
    +functionExist (String) : boolean
    + variableExist (String) : boolean
    +getVariable(String) : TreeNode
    +getFunction (String) : userFunction

}

@enduml